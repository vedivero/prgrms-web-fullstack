# 함수 포인터

## 1. 함수 포인터 선언

-  함수 포인터를 선언하려면 함수명 앞에 \*를 붙임
-  형식: 자료형 (\*함수 포인터 이름)(인자 목록)
-  예시: int (\*func)(int a)는 정수형을 반환하며 정수형 매개변수를 받는 함수 포인터 func를 선언하는 것

## 2. 함수 포인터 할당 및 호출

함수 포인터 선언 후 특정 함수를 가리키도록 할당
예시:

```
int Minus(int a, int b) {
    return a - b;
}

int main() {
    int (*fPtr)(int, int);
    fPtr = Minus; // 함수 포인터에 함수 할당
    int result = fPtr(20, 10); // 함수 포인터를 사용해 함수 호출
    printf("결과값: %d\n", result);
    return 0;
}
```

fPtr = Minus;로 함수 포인터가 Minus 함수를 가리키도록 설정하고, 이후 fPtr(20, 10);으로 함수 호출

## 3. 함수 포인터 사용 이유

-  유연성 확보

   컴파일 시점이 아닌 런타임에 함수의 메모리 위치를 결정하기 위해 함수 포인터를 사용함. 이를 통해 프로그램의 유연성을 극대화

-  정적 바인딩 vs 동적 바인딩

   컴파일 타임에 함수 호출을 정적 바인딩하는 대신 런타임에 함수 포인터로 동적 바인딩을 함으로써 다양한 함수 조합을 가능하게 만듦

-  플러그인 구조 구현

   Visual Studio Code에서 사용하는 확장(extension) 방식처럼, 새로운 기능을 추가하거나 변경할 때마다 재컴파일하지 않고 함수 포인터를 사용하여 새로운 기능을 동적으로 추가

## 4. 로봇 그림과 함수 포인터의 연관성

![alt text](image.png)

여러 모듈(함수)을 조립하듯이 함수 포인터로 다양한 함수를 연결하고 호출하여 유연하게 프로그램 동작을 설계

이와 같이 여러 개의 독립된 기능들을 조합하여 새로운 동작을 만들어내는 방식이 함수 포인터의 핵심 사용 이유



<br>
<br>
<br>

# 구조체

## 1. 하나 이상의 서로 다른 종류의 변수를 묶어서 새로운 데이터 타입을 정의

형식:

```
struct 구조체명 {
자료형 변수명1;
자료형 변수명2;
};
```

예시:

```
struct student {
char name[10];
int age;
int height;
};
```

## 2. 구조체 사용 이유

-  연관된 변수들을 하나로 묶어서 관리함으로써 데이터 관리에 유용
-  데이터의 양이 많아질 때 구조체를 사용하면 효율적
-  예시로 학생 관리 시스템에서 이름, 나이, 성별 등을 구조체로 묶어 한 명의 학생 정보를 하나의 그룹으로 관리

## 3. 구조체 변수 선언 및 접근

- 구조체 변수를 선언하여 사용:

    ```
    struct student st1, st2;
    ```

- 구조체 멤버에 접근할 때는 .(점)을 사용:

    ```
    st1.age = 25;
    st1.height = 178;
    ```

    학생 정보 출력 예제:
    ```
    #include <stdio.h>
    #include <string.h>

    struct student {
    char name[10];
    int age;
    int height;
    } st1;

    int main(void) {
    strcpy(st1.name, "이창현");
    st1.age = 25;
    st1.height = 178;
        printf("이름 = %s, 나이 = %d, 키 = %d\n", st1.name, st1.age, st1.height);
        return 0;
    }
    ```


<br>
<br>
<br>

# 공용체, enum

## 1. 공용체 (union)

- 정의: 공용체도 사용자 정의 자료형의 하나로, 구조체와 유사하지만 모든 멤버가 동일한 메모리 공간을 공유

    형식:
    ```
    union unTemp {
        char a;
        int b;
        double c;
    } un;
    ```
    - 구조체와 차이점: 구조체는 각 멤버가 별도의 메모리를 차지하지만, 공용체는 모든 멤버가 동일한 메모리 공간을 사용하여 가장 큰 자료형의 크기만큼 메모리를 할당받음
    - 예시:
        - 구조체: 각 멤버가 독립적으로 1바이트, 4바이트, 8바이트씩 차지
        - 공용체: 8바이트의 메모리만 할당되어 멤버들이 공유

## 2. 열거형 (enum)
- 정의: 열거형은 여러 상수 값을 한 곳에 모아 열거한 집합으로, enum 키워드를 사용하여 정의

- 형식:
    ```
    enum Week {
        sun = 0,
        mon,
        tue,
        wed,
        thu,
        fri,
        sat
    };
    ```
    - 사용 방법: 열거형의 첫 번째 값에 숫자를 할당하면, 이후 값들은 1씩 증가함. 예를 들어 sun = 0이면, mon = 1, tue = 2가 됨

- 예제:
    ```
    enum Week day = wed;

    switch (day) {
        case sun:
            printf("일요일\n");
            break;
        case wed:
            printf("수요일\n");
            break;
    }
    ```
    사용자가 day 값으로 wed를 선택하면 "수요일" 출력


<br>
<br>
<br>

# 동적 메모리 할당

## 1. 메모리 영역의 구성
메모리는 `코드 영역`, `스택 영역`, `힙 영역`, `데이터 영역`의 4가지로 구분

- 코드 영역

    - 프로그램의 실행 명령어들이 저장
    - CPU는 코드 영역에 저장된 명령어들을 순서대로 가져와 실행

- 스택 영역

    - 지역 변수 및 매개변수와 같은 함수 호출 시 사용하는 데이터가 저장
    - LIFO(Last In First Out) 구조로, 마지막에 들어온 데이터가 먼저 나감

    - 예시:
    - A와 B를 스택에 넣고 꺼낼 때, 먼저 B가 나가고 그다음에 A가 나감


- 힙 영역

    - 사용자가 프로그램 실행 중에 직접 할당하는 메모리 공간
    - 메모리를 동적으로 할당하고 필요 시 해제하여 사용
    - 힙 메모리는 malloc, free 함수를 통해 관리

- 데이터 영역

    - 전역 변수와 static 변수가 저장되는 공간.
    - 프로그램이 종료될 때까지 메모리에 남아 있음.

## 2. 동적 메모리 할당과 해제

- malloc 함수 사용법:

    - 형식:
    ```
    void* malloc(size_t size);
    ```
    - size: 할당할 메모리 크기를 바이트 단위로 입력
    - 메모리 할당 성공 시 메모리의 주소를 반환하며, 할당 실패 시 NULL 포인터를 반환


    예시:
    ```
    int* student = (int*)malloc(sizeof(int) * num);
    ```
- 메모리 해제:

    - 동적으로 할당한 메모리는 free 함수를 사용해 해제해야 함
    - 예시:
    ```
    free(student);
    ```

## 3. 예제 코드

```
#include <stdio.h>
#include <stdlib.h>

int main() {
    int num;
    int *student;

    printf("학생 수를 입력하세요: ");
    scanf("%d", &num);

    student = (int*)malloc(sizeof(int) * num);

    if (student == NULL) {
        printf("메모리가 할당되지 않았습니다.\n");
        return 0;
    }

    printf("할당된 메모리 크기는 %d입니다.\n", sizeof(int) * num);

    free(student);
    return 0;
}
```

- 설명:
    - 사용자가 입력한 학생 수에 따라 메모리를 동적으로 할당하고, 메모리 크기를 출력
    - 할당된 메모리는 사용 후 free 함수를 통해 해제해야 함


## 4. 메모리 구조
- 스택(Stack)과 힙(Heap)은 서로 다른 방향으로 메모리가 확장
    - 스택은 위에서 아래로, 힙은 아래에서 위로 자라남
    - 스택: 함수 호출 시 임시로 사용하는 메모리
    - 힙: 동적 메모리 할당 시 사용하는 메모리




<br>
<br>
<br>

# 추상화

## 1. 추상화란 무엇인가?
- 추상화는 대상에서 본질적인 특징만을 뽑아내는 과정

    - 복잡한 현실의 모든 세부 정보를 다루지 않고 필요한 핵심 정보만 남기는 것
    - 우리 일상 속 사물들은 다양한 모습으로 존재하지만, 공통된 특징을 추출하여 단순화
- 예시:

    - 진돗개, 치와와, 삽살개 → 개라는 하나의 공통된 개념으로 추상화
    - 그림에 등장하는 여러 형태의 동물도 결국 동물이라는 본질로 묶일 수 있음

## 2. 플라톤의 이데아와 추상화

- 이데아의 개념: 플라톤은 모든 사물의 본질적인 형태를 이데아(idea)라고 정의

    - 개별적인 개, 나무 등이 아닌 본질적인 개념으로서의 "개"와 "나무"를 중시
    - "진돗개", "치와와" 등의 개별적인 개를 보아도 우리는 공통된 개념의 개를 인식

- 플라톤과 제자들의 대화:

    - 플라톤이 물음: "너는 개를 본 적이 있느냐?"
    - 제자들의 대답: "네, 진돗개, 치와와, 삽살개를 보았습니다."
    >플라톤의 의도는 개별적인 모습이 아닌 본질적인 개념을 이해하는 것이 추상화의 본질임을 설명하는 것

## 3. 추상화의 철학적 비유

- 동굴의 비유:

    - 현실에서 관찰되는 모든 것은 본질의 그림자에 불과함
    - 동굴 속 그림자는 이데아 세계의 **원형(본질)**을 반영한 것이며, 이를 통해 사물의 본질을 이해할 수 있음.

- 추상화된 객체의 활용:

    - 프로그램에서 추상화된 객체는 복잡한 구현을 감추고 단순화된 인터페이스만 제공
    - 예: "동물" 객체는 "소리내기()", "움직이기()" 등의 추상적인 메서드만 노출하고, 각 동물 객체가 이를 구체적으로 구현

## 4. 객체지향 프로그래밍에서의 추상화

- 추상화 클래스와 인터페이스:
    - 추상화는 객체지향 프로그래밍(OOP)의 중요한 개념
    - 공통된 특징을 가진 객체들은 추상 클래스나 인터페이스로 정의
    - 이를 상속한 객체들이 구체적인 행동을 구현함으로써 코드의 재사용성과 유지보수성을 높임.
