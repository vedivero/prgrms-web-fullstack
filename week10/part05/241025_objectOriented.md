# 객체 지향 프로그래밍 방식

## 1. 왜 객체지향 철학을 이해해야 하는가?

- 자바스크립트와 같은 언어는 객체를 사용하는 객체 기반 언어임.
- 객체 생성 원리를 이해하면 객체를 더 효율적으로 사용할 수 있음.
- 타입스크립트와 리액트 같은 현대 웹 프레임워크에서는 객체지향 개념이 필수적임.

## 2. 객체지향 철학의 이해

- 객체(Object): 실세계의 ‘사물’ 또는 추상적인 개념을 나타내는 단위.
- 지향(Oriented): ~를 향한다는 의미를 가지며, 객체 중심으로 프로그램을 설계하는 방식임.

- 비유:

    레고 블록과 같이 작은 객체들이 조합되어 복잡한 구조를 만듦.
    각각의 레고 블록이 객체에 해당하며, 이를 조립하여 하나의 완성된 모델(프로그램)을 구축.

## 3. 구조적 프로그래밍과 객체지향 프로그래밍

- 구조적 프로그래밍: 순차적, 하향식, 폭포수 방식으로 설계.

    - 기본 단위는 함수.
    - 예시 코드:

    ```
    int Add(int a, int b);
    int Minus(int a, int b);

    int main(void) {
        Add(1, 2);
        Minus(4, 3);
        return 0;
    }
    ```
    - 설계가 하향식으로 진행되며, 함수들이 단계적으로 호출됨.

- 객체지향 프로그래밍: 기능 단위는 객체임.

    - 이벤트 기반 프로그램(예: 윈도우 프로그램)에서 자주 사용됨.
    - 프로그램 내 모든 요소를 객체 단위로 나눠 상호작용을 구현함.

## 4. 객체지향 프로그래밍의 특징
- 캡슐화(Encapsulation): 데이터와 메서드를 객체 안에 감추어 외부에서 접근을 제한.
- 상속(Inheritance): 기존 객체를 바탕으로 새로운 객체를 생성.
- 다형성(Polymorphism): 동일한 메서드가 다양한 방식으로 동작하도록 함.
- 추상화(Abstraction): 복잡한 내부 구현은 감추고 필요한 부분만 노출.

## 5. 객체지향과 이벤트 기반 프로그램 예시
- 모든 윈도우 애플리케이션은 이벤트 기반 객체들로 이루어짐.
    - 예: 마우스 클릭, 키보드 입력 등 이벤트가 발생할 때마다 각 객체가 특정 동작을 수행.
    - 객체 간의 메시지 전달로 상호작용이 이루어짐.


<br>
<br>
<br>

# 추상화

## 1. 추상화란 무엇인가?
- 추상화는 대상에서 본질적인 특징만을 뽑아내는 과정임.

    - 복잡한 현실의 모든 세부 정보를 다루지 않고 필요한 핵심 정보만 남기는 것.
    - 우리 일상 속 사물들은 다양한 모습으로 존재하지만, 공통된 특징을 추출하여 단순화함.
- 예시:

    - 진돗개, 치와와, 삽살개 → 개라는 하나의 공통된 개념으로 추상화.
    - 그림에 등장하는 여러 형태의 동물도 결국 동물이라는 본질로 묶일 수 있음.

## 2. 플라톤의 이데아와 추상화

- 이데아의 개념: 플라톤은 모든 사물의 본질적인 형태를 이데아(idea)라고 정의함.

    - 개별적인 개, 나무 등이 아닌 본질적인 개념으로서의 "개"와 "나무"를 중시함.
    - "진돗개", "치와와" 등의 개별적인 개를 보아도 우리는 공통된 개념의 개를 인식함.

- 플라톤과 제자들의 대화:

    - 플라톤이 물음: "너는 개를 본 적이 있느냐?"
    - 제자들의 대답: "네, 진돗개, 치와와, 삽살개를 보았습니다."
    >플라톤의 의도는 개별적인 모습이 아닌 본질적인 개념을 이해하는 것이 추상화의 본질임을 설명하는 것임.

## 3. 추상화의 철학적 비유

- 동굴의 비유:

    - 현실에서 관찰되는 모든 것은 본질의 그림자에 불과함.
    - 동굴 속 그림자는 이데아 세계의 **원형(본질)**을 반영한 것이며, 이를 통해 사물의 본질을 이해할 수 있음.

- 추상화된 객체의 활용:

    - 프로그램에서 추상화된 객체는 복잡한 구현을 감추고 단순화된 인터페이스만 제공함.
    - 예: "동물" 객체는 "소리내기()", "움직이기()" 등의 추상적인 메서드만 노출하고, 각 동물 객체가 이를 구체적으로 구현함.

## 4. 객체지향 프로그래밍에서의 추상화

- 추상화 클래스와 인터페이스:
    - 추상화는 객체지향 프로그래밍(OOP)의 중요한 개념임.
    - 공통된 특징을 가진 객체들은 추상 클래스나 인터페이스로 정의됨.
    - 이를 상속한 객체들이 구체적인 행동을 구현함으로써 코드의 재사용성과 유지보수성을 높임.





<br>
<br>
<br>






# 캡슐화

## 1. 캡슐화란?
- 캡슐화는 은닉화 또는 숨기는 것을 의미함.
    - 객체의 데이터를 외부에서 직접 접근하지 못하도록 하고, 함수를 통해서만 접근할 수 있도록 제한하는 것.

- 캡슐화의 목적:
    - 내부 구현을 숨기고 객체의 상태를 보호함.
    - 데이터를 단순히 숨기는 것이 아니라, 외부에서 데이터를 조작할 수 있는 인터페이스를 제공하는 것임.

## 2. 캡슐화의 구성 요소
- 은닉된 데이터: 외부에서 직접 접근할 수 없는 객체 내부의 상태.

- 멤버 함수: 은닉된 데이터를 조작하거나 반환하는 함수로, 외부에서 이 함수를 통해서만 데이터에 접근 가능.

- 비유:

    - 약 캡슐처럼 내부 구성 성분(데이터)은 외부에서 보이지 않지만, 약을 복용하면 효과(데이터 접근)가 나타남.
    - 즉, 외부에서는 약의 효과만 알 뿐, 내부 성분에 직접 접근할 수 없음.

## 3. 캡슐화의 장점

- 데이터 보호: 외부로부터 객체의 상태를 보호하여 무결성을 유지
- 인터페이스 단순화: 불필요한 내부 구현을 감추고, 단순한 인터페이스만 제공함으로써 코드 사용이 용이해짐.
- 유지보수성: 내부 구현을 바꾸더라도 외부 인터페이스는 유지되므로 코드 변경이 유연해짐.

## 4. 결론
- 캡슐화는 객체지향 프로그래밍(OOP)의 중요한 개념 중 하나로, 데이터의 무결성과 안전성을 보장하고 인터페이스의 단순성을 제공
- 외부에서의 직접적인 데이터 조작을 막고, 객체의 일관성을 유지하는데 필수적인 역할






<br>
<br>
<br>



# 클래스


## 1. 클래스란?
- 사전적 의미: 클래스는 학급이라는 의미를 가짐.
- 프로그래밍에서의 클래스: 사용자가 정의한 데이터 타입을 의미.
- 데이터와 메서드를 묶어서 새로운 데이터타입으로 정의하며, 추상적 데이터타입이라 부름.


## 2. 클래스의 구성
- 구성 요소:

    - 필드(멤버 변수): 사물의 상태를 나타냄.
    - 메서드(멤버 함수): 사물의 행동을 정의.

- 예시:

    - 사람: 피부색, 키, 나이, 성별 등의 필드와 생각하다, 걷다 같은 메서드를 가짐.
    - 차: 배기량, 연료 종류 같은 필드와 달리다, 멈추다 같은 메서드를 가짐.
    - 노트북: CPU, 메모리 용량 같은 필드와 충전하다, 부팅하다 같은 메서드를 가짐.


## 3. 클래스 선언 형식
- 클래스는 class 키워드를 사용해 선언.

    ```
    class Dog {
    private:
        int eyes;
        int nose;

    public:
        void bark() {
            cout << "멍멍" << endl;
        }
    };
    ```

    - 접근 지정자:
        - public: 누구나 접근 가능.
        - protected: 상속 관계에서만 접근 가능.
        - private: 클래스 내부에서만 접근 가능.


## 4. 객체의 생성

-  객체: 클래스의 인스턴스를 의미.

```
Dog* a = new Dog(); // Dog 객체 생성 후 힙에 할당
```
#### 힙 메모리에 할당된 객체를 스택의 포인터가 참조하는 구조.


## 5. 클래스의 역할

- 추상화: 현실 세계의 복잡한 개념을 클래스로 추상화해 표현.
- 캡슐화: 데이터를 숨기고 메서드를 통해서만 접근하도록 함.
- 재사용성: 한 번 정의한 클래스를 여러 곳에서 재사용 가능.




<br>
<br>
<br>



# 생성자


## 1. 생성자의 정의

- 생성자는 객체가 생성될 때 자동으로 호출되는 특별한 메서드.
- 객체의 변수들을 초기화하기 위해 사용.

## 2. 생성자의 특징

- 모든 변수는 선언 시 초기화되어야 함.
- 객체도 변수이기 때문에 선언 시 반드시 초기화가 필요.
- 생성자는 객체 생성 시 초기화 전용 메서드로 사용됨.


## 3. 생성자의 기본 형식

- 생성자는 클래스의 이름과 동일하며 반환 타입을 지정하지 않음.

```
class Dog {
public:
    Dog() {  // 생성자
        cout << "Dog 객체가 생성되었습니다." << endl;
    }
};
```

## 4. 생성자의 호출

- 객체가 생성될 때 자동으로 호출됨.

```
int main() {
    Dog myDog;  // Dog 객체 생성 시 생성자가 자동 호출됨
    return 0;
}
```

## 5. 생성자의 역할
- 객체가 생성될 때 초기 상태를 설정해 줌.
- 필수 초기화가 필요한 변수를 설정.
- 코드의 가독성과 안정성을 높임.




<br>
<br>
<br>



# 상속성


## 상속성의 개념

- 현실 세계에서의 상속 개념을 설명.
    - 부모님이 나에게 집을 상속.
    - 부모님이 나에게 100만 원을 상속.

## 생물의 계층 구조

- 상위 개념에서 하위 개념으로 점차 구체화되는 구조를 보여줌.
    - 생물 → 동물/식물 → 개/고양이, 장미/개나리

## 클래스 간 상속 개념

- 이미 완성된 클래스를 다른 클래스에서 상속 가능.
- 부모 클래스로부터 상속을 받을 때는 클래스 이름 뒤에 콜론(:)을 붙임.
    - Java의 경우 extends 키워드를 사용하여 부모 클래스를 상속.




<br>
<br>
<br>



# 다형성(Polymorphism)의 개념

- 다형성은 객체지향 프로그래밍(OOP)의 핵심 개념 중 하나로, 동일한 이름의 함수가 다양한 형태로 동작할 수 있게 하는 특성
- 다형성은 크게 **오버로딩(Overloading)**과 **오버라이딩(Overriding)**으로 나뉨



<br>
<br>
<br>



# 오버로딩

- 정의:
    - 오버로딩은 동일한 이름의 메서드를 여러 개 정의하되, 매개변수의 개수나 타입이 다르게 정의하는 기법입니다.

- 특징:

    - 같은 함수 이름이지만 매개변수의 타입이나 개수가 다르면 구분
    - 컴파일 타임에 어떤 메서드가 호출될지 결정(정적 바인딩).

- 예제 코드:

```
int Plus(int a, int b) {
    return a + b;
}
char Plus(char a, char b) {
    return a + b;
}
double Plus(double a, double b) {
    return a + b;
}
```



<br>
<br>
<br>



# 오버라이딩


- 정의:
    - 오버라이딩은 부모 클래스에서 정의한 메서드를 자식 클래스에서 재정의하는 것을 의미
    - 자식 클래스가 부모 클래스의 메서드를 자신의 요구에 맞게 변경하는 경우에 사용

- 특징:

    부모 클래스와 자식 클래스 모두 동일한 메서드 이름과 매개변수를 사용
    런타임에 어떤 메서드가 호출될지 결정(동적 바인딩).

- 예제 코드:

    ```
    class Dog {
        public virtual void Bark() {
            Console.WriteLine("멍멍");
        }
    }

    class Poodle : Dog {
        public override void Bark() {
            Console.WriteLine("푸들이 멍멍");
        }
    }

    static void Main() {
        Dog dog = new Poodle();
        dog.Bark();  // 출력: 푸들이 멍멍
    }
    ```

- 해석:
    - 부모 클래스 Dog의 Bark 메서드를 자식 클래스 Poodle에서 재정의
    - 런타임에 dog 객체가 Poodle 타입으로 생성되었기 때문에 Poodle의 Bark가 호출



<br>
<br>
<br>


# 오버로딩 vs 오버라이딩의 차이점

| **구분**          | **오버로딩(Overloading)**                     | **오버라이딩(Overriding)**                 |
|------------------|-----------------------------------------------|-------------------------------------------|
| **주요 목적**    | 같은 이름의 메서드를 다양한 방식으로 사용      | 상속받은 메서드를 재정의                  |
| **발생 시점**    | 컴파일 타임(정적 바인딩)                      | 런타임(동적 바인딩)                        |
| **매개변수**     | 매개변수의 개수나 타입이 달라야 함            | 매개변수가 동일해야 함                     |
| **클래스 관계**  | 같은 클래스 내부                              | 상속 관계에 있는 클래스 간에 사용          |


<br>
<br>
<br>



# 인터페이스


## 인터페이스 정의
- 인터페이스는 메서드의 목록만 선언하는 명세(Specification)임.
- 메서드의 구현은 포함하지 않음.
- 접근제어자와 함께 interface 키워드로 선언함.

## 클래스의 인터페이스 상속
- 클래스는 인터페이스를 상속받아 기능을 구현해야 함.
- class 자식클래스이름 : 인터페이스 형태로 작성함.

## 인터페이스 사용 이유
- 인터페이스는 추상 메서드만 가지며, 구체적인 구현은 포함하지 않음.
- 새로운 기능 추가와 기존 기능 수정 시 유연하게 활용 가능함.
- 협업 시 표준화를 위해 사용함.

## 추상 클래스 상속
- 기능 확장이 목적임.
- 예: 기본 스마트폰 클래스에서 각 제조사별로 기능 확장함.

## 스마트폰과 인터페이스 상속 예시
- 스마트폰 기본 기능: 통화, 문자메시지, 와이파이, 블루투스, 멀티미디어.
- 각 인터페이스에 기능 선언하고, 자식 클래스에서 해당 기능을 구현함.

## 스마트폰 기능의 구현
- 예: 통화기능(), 문자메시지기능(), 와이파이기능() 등을 클래스에서 구현함
- 각 스마트폰은 다양한 기능 인터페이스를 구현해야 함.





<br>
<br>
<br>



# 람다

## 익명 메서드
- 메서드를 미리 정의하지 않고 사용할 때 정의함.
- 익명 메서드를 사용하면 코드가 간결해짐.
- 별도의 메서드를 생성하지 않아 코드 오버헤드를 줄일 수 있음.
- 내용이 복잡하면 적합하지 않음.
- 주로 람다식에서 사용됨.

## 람다식의 목적
- 기존 익명 메서드를 더 간결하게 만듦.
- 코드를 짧고 간단하게 표현함.

## 일반 메서드 기반 코드 예제
- 메서드를 미리 정의하고 호출하여 사용함.

```
static int Add(int a) {
    return a + 1;
}
static void Main(string[] args) {
    int k = Add(3);
    Console.WriteLine(k);
}
```

## 익명 메서드와 델리게이트 사용 예제
- 델리게이트를 통해 익명 메서드를 정의하고 사용함.
- 코드 예제:

class HelloWorld {
    static int Add(int a) {
        return a + 1;
    }
    delegate int CalcDele(int x);
    static void Main() {
        Console.WriteLine(Add(3));
        CalcDele d = delegate (int x) {
            return x + 1;
        };
        Console.WriteLine(d(3));
    }
}

- 델리게이트를 활용해 동적으로 메서드를 정의함.
- 익명 메서드를 사용해 간단한 로직을 구현할 때 유용함.
















<br>
<br>
<br>



# 생성자

