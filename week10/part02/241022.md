# 2024.10.22 / week 10 / part.02


## flow control

프로그래밍에서 흐름 제어란 코드가 실행되는 순서와 조건을 제어하는 방식을 의미

이를 통해 특정 조건에 따라 코드의 실행 흐름을 변경하거나, 반복적으로 실행하도록 할 수 있음

자바스크립트를 포함한 대부분의 프로그래밍 언어에는 다양한 흐름 제어 구조가 있음


### 제어 흐름의 종류

1. goto (다른 구문에서 시작)

    프로그램의 흐름을 특정 위치로 즉시 이동시키는 명령어.

    C와 같은 일부 언어에서는 사용되지만, 자바스크립트에서는 지원하지 않음.

2. choice

    조건이 충족될 때만 명령문을 실행하는 구문.

    자바스크립트에서는 if, else if, else, switch가 해당됨.

    >if-else, switch

3. loop

    특정 조건이 만족될 때까지 명령문을 0회 이상 반복.

    자바스크립트에서는 for, while, do-while이 해당됨.

    >Collection loop, General loop

4. continue

    현재 실행 중인 반복문의 남은 부분을 건너뛰고, 다음 반복 실행.

    > Loop continuation

5. break

    반복문 또는 switch 구문을 즉시 종료.

    > Loop early exit, 함수 실행 정지



## 표현식과 문의 개념

### 표현식 

하나의 값으로 평가될 수 있는 코드를 의미.

즉, 실행되면 값을 반환하는 코드 조각

값으로 평가될 수 있는 문은 모두 표현식


- 리터럴 표현식

    리터럴 값 자체가 표현식으로 사용
    ```
    10          // 숫자 리터럴
    'Hello'     // 문자열 리터럴
    true        // 불리언 리터럴
    ```

- 변수 표현식

    변수는 할당된 값으로 평가
    ```
    let x = 5;
    x  // 변수 표현식으로 평가되면 5가 반환됨
    ```

- 산술 표현식

    산술 연산을 수행하며, 결과 값으로 평가

    ```
    2 + 3      // 5
    10 * 2     // 20
    ```

- 논리 표현식

    논리 연산을 수행하며, 불리언 값으로 평가

    ```
    true && false  // false
    10 > 5         // true
    ```


### 문 (statement)

문(Statement)

프로그램의 실행 흐름을 제어하는 완결된 구문.

자바스크립트에서 명령을 내리는 기본 단위.



## choice


### if-else

- 기본 구조
    
    조건이 참일 때와 거짓일 때 각각 다른 코드를 실행.

    ```
    if (조건) {
        // 조건이 참일 때 실행
    } else {
        // 조건이 거짓일 때 실행
    }
    ```

### switch

- 기본 구조
    
    조건이 참일 때와 거짓일 때 각각 다른 코드를 실행.

    ```
    switch (표현식) {
    case 값1:
        // 값1과 표현식이 일치할 때 실행할 코드
        break;
    case 값2:
        // 값2와 표현식이 일치할 때 실행할 코드
        break;
    default:
        // 모든 case에 해당하지 않을 때 실행할 코드
    }
    조건이 거짓일 때 실행
    }
    ```

## conditional loop


### 1. 시작할 때 조건을 평가하는 루프

루프가 시작되기 전에 조건을 평가.

조건이 참이면 루프가 실행되며, 반복마다 조건을 다시 평가.

자바스크립트의 while 루프와 for 루프가 여기에 해당.

    let i = 0;

    while (i < 3) {
        console.log(i);
        i++;
    }

### 2. 마지막에 조건을 평가하는 루프

루프를 한 번 실행한 후 조건을 평가.

조건이 참이면 다시 루프 실행.

    let i = 0;

    do {
    console.log(i);
    i++;
    } while (i < 3);

- while과 for: 시작할 때 조건 평가.
- do-while: 마지막에 조건 평가.
- 조건이 참일 동안 코드를 반복 실행.

### for loop

- C 언어에서 유래한 반복문 형식.
- while문과 다르게 루프와 관련된 변수를 루프 내부에서 직접 제어.
- 루프 변수의 비교와 증감을 위해 별도의 문법 명시 필요.
- 루프 변수를 활용해 명시적으로 카운트를 관리해야 함.

구조

    for (초기화; 조건식; 증감문) {
    // 반복할 코드
    }

    초기화 : 반복에 사용할 변수를 선언하고 초기화.
    조건식 : 반복을 계속할 조건을 명시. 조건이 참일 동안 반복.
    증감문 : 각 반복 후 변수의 값을 증가 또는 감소시킴.



### Collection loop (Foreach 루프) 설명

-  개념

    컬렉션 내의 항목들을 순회하기 위한 제어 흐름문.

    for문과 다르게 루프 변수(카운터)를 명시적으로 관리하지 않음.



### 자바스크립트의 Collection Loop (Foreach 루프)



1. for...of 문

    반복 가능한 객체(Array, Set, String 등)를 순회.

    각 반복에서 객체의 값을 반환.
    ```
    for (const 변수 of 객체) {
       // 반복할 코드
    }
    ```
    ```
    const foo = 'apple';

    for (const char of foo) {
        console.log(char);
    }
    //a
    //p
    //p
    //l
    //e
    ```


2. for...in 문

    객체의 **열거 가능한 속성(key)**을 순회.

    배열, 객체 등에서 속성의 이름을 반환.

    ```
    for (const 변수 in 객체) {
        // 반복할 코드
    }
    ```
    ```
    const foo = {
        apple: '🍎',
        banana: '🍌',
    };

    for (const key in foo) {
        console.log(key);
    }
    ```
    ```
    //apple
    //banana
    ```


## break, continue

1. break문

    제어 흐름을 중단하고, 반복문 또는 switch 문을 즉시 종료.
    
    가장 가까운 반복문 또는 switch문을 종료하고, 다음 명령으로 이동.


2. continue문

    현재 반복의 남은 부분을 건너뛰고, 다음 반복으로 이동.

    전체 반복을 종료하지 않고, while, do-while, for문을 재시작.


## 예외 상황과 종류


### 예외의 원인

- 코드 레벨의 문제 (예: 변수 사용 오류)

- 하드웨어, 디바이스 문제 (예: 네트워크 장애)

- 라이브러리 손상 또는 외부 종속성 문제

- 사용자 입력 실수

### 예외의 종류

#### 1 ECMAScript Error

자바스크립트 언어에서 발생하는 오류 유형.

- RangeError: 허용되지 않은 범위 사용 시 발생.

    ```
    new Array(-1); // RangeError: Invalid array length
    ```

- ReferenceError: 존재하지 않는 변수를 참조할 때 발생.

    ```
    console.log(x); // ReferenceError: x is not defined
    ```

- SyntaxError: 문법이 잘못된 경우 발생.

    ```
    const a = ; // SyntaxError: Unexpected token
    ```

- TypeError: 예상한 자료형이 아닐 때 발생.
    ```
    const a = 1;
    a(); // TypeError: a is not a function
    ```

#### DOMException

Web API 사용 시 발생하는 예외 유형.

- NetworkError : 네트워크 문제 발생 시.
- AbortError : 작업이 중단될 때.
- TimeoutError : 작업 시간이 초과되었을 때.

### 예외 처리의 필요성
예외 상황을 제대로 처리하지 않으면 프로그램이 멈출 수 있음.

try-catch 구문을 사용해 예외를 처리하여 안정성을 높임.


## thorw, error객체

### throw문
예외를 발생시키기 위해 사용.

catch 블록에서 에러 객체를 처리.

throw문 이후의 코드는 실행되지 않음.

#### 예외 발생 시 흐름
현재 함수의 실행이 즉시 중지.

에러 객체와 함께 예외가 throw.

catch 블록이 있을 경우 catch로 전달. (catch 블록이 없으면 프로그램 종료.)

```
const foo = () => {
  console.log(1);
  throw '여기!';
  console.log(2); // 실행되지 않음
};

foo();
```

### Error 객체

사용자가 직접 Error 객체를 생성하여 사용 가능.

new Error() 생성자를 통해 에러 메시지 정의.

Error 객체의 message와 name 속성을 설정 가능.

```
const foo = () => {
  console.log(1);
  const customError = new Error();
  customError.name = 'ErrorName';
  customError.message = '에러 발생';
  
  throw customError;
  console.log(2); // 실행되지 않음
};

foo();
```

Error.message: 에러에 대한 메시지.

Error.name: 에러의 이름 지정.

ECMAScript 표준에서 다양한 내장 에러 유형 제공.

## try...catch문과 예외 처리


### 1. 콜 스택 (Call Stack)과 예외 처리

- 스택 자료구조: FILO (First In, Last Out) 구조로, 마지막에 추가된 것이 먼저 제거됨.

- Call Stack: 자바스크립트 코드 실행 시 함수 호출이 쌓이는 구조.

    - 함수가 호출될 때마다 스택에 추가(push).

    - 함수가 종료되면 스택에서 제거(pop).

- 예외 발생 시: 스택을 따라 올라가면서 해당하는 catch문이 있는지 탐색.

    - catch문이 없으면 프로그램 종료.
    
    - catch문이 있으면 그곳에서 예외 처리.


### 2. try...catch문
- 예외 처리를 위해 사용하는 구문.
- try 블록에서 발생한 예외를 catch 블록에서 처리.
- 예외가 발생하지 않으면 catch 블록은 실행되지 않음.

구조

    try {
        // 예외가 발생할 가능성이 있는 코드
    } catch (error) {
        // 예외 처리 코드
    }

예제
```
try {
    const result = JSON.parse("{ invalid json }");
} catch (error) {
    console.log("에러 발생:", error.message);
}
```

### 3. finally 블록
- finally는 예외 발생 여부와 상관없이 항상 실행됨.
- 자원 정리나 마무리 작업에 유용.

```
try {
    console.log("시작");
    throw new Error("예외 발생");
} catch (error) {
    console.log("에러 처리:", error.message);
} finally {
    console.log("항상 실행되는 코드");
}
```

### 4. 예외 처리 사례
- 네트워크 오류 처리: 서버와의 통신이 실패할 때.
- 비즈니스 로직 처리: 유효하지 않은 데이터가 들어올 때.
- 사용자 입력 오류 처리: 잘못된 형식의 입력이 들어올 때.


## 객체란?

- 객체는 속성을 가진 독립적인 개체
- 객체는 key-value 쌍으로 구성되며, 속성을 통해 값을 가짐
- 속성 접근은 점(.) 또는 대괄호([]) 표기법을 사용
- 메서드는 객체에 속한 함수로 정의 할 수 있음

### 객체 생성 방법

1. 리터럴 표기:

    `const 객체명 = { 속성: '값' };`

    객체의 속성을 직접 정의.

2. 생성자 함수:

    `function Person(name, age) { this.name = name; this.age = age; }`

    new 키워드로 인스턴스 생성.

3. Object.create:

    `const 새로운객체 = Object.create(기존객체);`

    기존 객체를 기반으로 새로운 객체 생성.



## 객체 속성 control

### 1. 객체의 특징
- 객체는 mutable(변경 가능)하다.

- 참조형 전달로 인해 객체의 변경이 다른 참조된 객체에도 영향을 미칠 수 있음

### 2. 객체 속성 동적 생성

- 존재하지 않는 속성을 참조하여 값을 할당하면 속성이 동적으로 추가됨.
    ```
    const obj = {};
    obj.newProp = "value"; // 동적 생성
    ```



## 객체 비교와 Refference

### 1. 객체 비교 (Reference type)
객체는 `참조 값(메모리 주소)`을 비교.

동일한 속성 값을 가진 객체라도 메모리 주소가 다르면 다른 객체로 간주.

```
const foo = { name: 'apple' };
const bar = { name: 'apple' };
console.log(foo === bar); // false
console.log(foo === foo); // true
```

### 2. 객체 복사 시 주의점
동일한 객체를 다른 변수에 할당하면 같은 메모리 주소를 참조.

하나의 객체를 수정하면 참조된 모든 변수에 영향을 미침.

```
const person = { name: 'Jason', age: 25 };
const joy = person;
joy.name = 'Joy';
console.log(person); // { name: 'Joy', age: 25 }
```

### 3. 얕은 복사 (Shallow Copy)
- 객체의 첫 번째 레벨까지만 복사, 내부 객체는 참조를 유지.

```
const shallowCopy = Object.assign({}, person);
const spreadCopy = { ...person };
```

- 내부 객체 수정 시 복사된 모든 객체에 영향.
```
joy.address.country = 'Japan';
console.log(kei.address.country); // 'Japan'
```

### 4. 깊은 복사 (Deep Copy)
- 모든 중첩된 객체까지 완전히 복사.
- 깊은 복사 방법:
    lodash 라이브러리의 cloneDeep() 사용.
    ```
    import cloneDeep from 'lodash/cloneDeep';
    const joy = cloneDeep(person);
    ```
    JSON.stringify()와 JSON.parse() 사용.
    ```
    const personStr = JSON.stringify(person);
    const kei = JSON.parse(personStr);
    ```
> 깊은 복사된 객체는 원본과 독립적임.



## 객체 종류와 분류

### 1. 객체의 분류
표준 빌트인 객체 (ECMAScript): 자바스크립트 언어의 기본 객체들.

호스트 객체 (브라우저 환경): 브라우저에서 제공하는 DOM API와 같은 객체들.

### 2. 표준 빌트인 객체 종류 (ECMAScript)
- 기초 객체:

    Object, Function, Boolean, Symbol
- 오류 객체:

    Error
- 숫자와 날짜:

    Number, BigInt, Math, Date
- 텍스트 처리:

    RegExp (정규 표현식), String (문자열)
- 컬렉션 (Collection):

    인덱스 기반: Array (배열)
    키 기반: Map, Set, ...
- 구조화된 데이터:

    JSON


### 3. 빌트인 객체의 형식
- 정적(static) 속성 및 메서드:

    클래스 수준에서 사용되는 속성 및 메서드.
- 인스턴스(instance) 속성 및 메서드:

    각 객체 인스턴스에서 사용되는 속성 및 메서드.
    예: Number.prototype.toFixed()는 Number 객체의 인스턴스에서 사용 가능.
- 프로토타입 상속:

    기본적으로 모든 객체는 Object의 속성을 상속받음.
- 상속된 메서드 예시:

    toString(), toLocaleString(), valueOf().


### 4. 활용 예시
- Number 인스턴스 메서드 호출:

```
let num = 123.456;
console.log(num.toFixed(2)); // '123.46'
```

- JSON 데이터 처리:
```
const data = { name: "Alice", age: 30 };
const jsonString = JSON.stringify(data);
console.log(jsonString); // '{"name":"Alice","age":30}'
```






















## Number, Math
































## Date


































## 문자열



























## 정규 표현식
































## Collection




































## index collection


































## Map, WeakMap





































## Set, WakSet
























## JSON 객체


















## 국제화

























## 프로토 타입과 생성자 함수

























## 프로토타입 chain과 상속








