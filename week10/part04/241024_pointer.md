# 포인터

### 원격 테스크톱 비유

해당 컴퓨터의 주소 값을 알고 있으면 해당 주소에 대한 제어가 가능

이와 같이 해당 메모리의 주소 값을 알면, 해당 데이터에 대한 제어가 가능

![alt text](image.png)

<br>

## 1. 포인터의 개념

1. 포인터의 개념

   -  포인터는 변수의 메모리 주소를 저장하는 변수를 의미함.
   -  변수의 주소값을 통해 메모리에 직접 접근하여 값을 읽고 쓸 수 있음.
   -  보통 포인터는 해당 메모리를 가리킨다고 표현됨.
      예시:

   ```
   char a = 'A';
   int b = 100;
   double c = 3.14;
   ```

   위의 코드에서는 각각의 변수 a, b, c가 각기 다른 메모리 공간에 저장.

   메모리 주소를 저장하면 포인터를 통해 해당 메모리 값에 접근할 수 있음.
   
<br>

3. 포인터 변수 선언 및 사용

   -  포인터 변수는 일반 변수명 앞에 \* 기호를 붙여 선언함.
   -  **주소 연산자(&)**를 사용해 변수의 주소값을 가져올 수 있음.

   포인터 선언 예시:

   ```
   char *pA;
   int *pB;
   double *pC;
   ```

   포인터 초기화 및 사용 예시:

   ```
   int b = 100;
   int \*pB = &b; // pB는 변수 b의 주소를 가리킴
   ```
   
<br>

4. 포인터 사용 예제

   -  포인터 변수를 사용해 메모리 주소와 값을 출력하는 코드.

      ```
      #include <stdio.h>

      int main(void) {
      int b = 100;
      int \*pB = &b; // pB는 b의 주소를 가리킴

          printf("b = %d\n", b);
          printf("&b = %p\n", &b);
          printf("pB = %p\n", pB);
          printf("*pB = %d\n", *pB); // 포인터를 통한 값 출력

          return 0;

      }
      ```

      실행 결과:

      ```
      b = 100
      &b = 0x7fffd505537c
      pB = 0x7fffd505537c
      \*pB = 100
      ```

   4. 포인터와 메모리 구조
      포인터 변수는 메모리 주소를 저장하며, 해당 주소에 접근해 값을 읽거나 수정할 수 있음.
      예를 들어, pB는 변수 b의 주소를 가리키고, 이를 통해 b의 값을 출력하거나 변경할 수 있음.

   ## 5. 포인터의 활용

   -  포인터는 동적 메모리 할당이나 함수 인자 전달에 유용하게 사용됨.
   -  포인터를 잘 활용하면 메모리 자원을 효율적으로 사용할 수 있으며, 배열과 문자열 처리에도 필수적임.

<br><br>


# 포인터와 배열
<br>

## 1. 배열 이름의 의미

-  배열의 이름은 해당 배열의 첫 번째 요소의 주소값을 의미함.
-  즉, 배열 이름 자체가 첫 번째 요소를 가리키는 포인터처럼 동작함.

   예시:

   ```
   int arr[] = {1, 2, 3, 4, 5};
   ```

   -  이 경우, arr은 arr[0]의 주소를 가리킴.
   -  arr과 &arr[0]의 값은 동일함.
     
<br>

## 2. 배열 요소의 주소 출력 예제

### 배열의 첫 번째 요소와 배열의 이름이 일치한 것을 증명

```
#include <stdio.h>

int main() {
int arr[] = {1, 2, 3, 4, 5};

for (int i = 0; i < 5; i++) {
    printf("%d\n", arr[i]);        // 배열 값 출력
    printf("%p\n", &arr[i]);       // 각 요소의 주소 출력
}

    printf("배열의 이름 : %p\n", arr); // 배열 이름이 가리키는 주소 출력
    return 0;
}
```

실행 결과:

```
1
0x7ffe0f1e25b0
2
0x7ffe0f1e25b4
3
0x7ffe0f1e25b8
4
0x7ffe0f1e25bc
5
0x7ffe0f1e25c0
배열의 이름 : 0x7ffe0f1e25b0
```

-  배열 이름은 배열의 첫 번째 요소의 주소와 동일한 값을 가짐.
  
<br>

## 3. 배열 이름과 포인터의 차이

-  배열 이름은 첫 번째 요소의 주소를 가리키지만, 일반 포인터와는 차이가 있음.
-  배열 이름은 상수 포인터처럼 동작하며, 주소를 변경할 수 없음.

   잘못된 예시:

   ```
   int arr[] = {1, 2, 3, 4, 5};
   int temp = 10;
   arr = temp; // 오류 발생
   ```

배열 이름에 다른 주소를 대입하려고 시도하면 오류가 발생함.

<br>

## 4. 결론

-  배열의 이름은 포인터와 유사하지만 상수 포인터로 동작하여 주소를 변경할 수 없음.
-  포인터를 사용하면 배열의 요소에 접근할 수 있으며, 배열과 포인터의 관계를 이해하는 것은 메모리 관리를 효과적으로 수행하는 데 중요함.

<br><br>

# 함수와 포인터

<br>

## 1. 기본적인 함수의 인자 전달 방식

-  일반적인 함수 인자 전달은 값에 의한 복사(pass by value) 방식임.
-  즉, 실인수(함수 호출 시 전달되는 값)의 값이 형식 인수(함수의 매개변수)에 복사됨.
-  복사된 값은 함수 내에서만 사용되며, 원래 변수의 값에는 영향을 주지 않음.

   예제:

   ```
   #include <stdio.h>

   void Temp(int b) {
       b = 20; // b에 20 대입 (원본 값에는 영향 없음)
   }

   int main(void) {
       int a = 10;
       Temp(a); // a의 값이 Temp 함수로 복사됨
       printf("a = %d\n", a); // a의 값은 여전히 10
       return 0;
   }
   ```

   ```
   결과:
   a = 10
   ```

   > a의 값이 복사되어 함수에 전달되므로, 함수 내에서 b의 값이 변경되어도 a는 영향을 받지 않음.
   
<br>

## 2. 배열의 전달 방식: 포인터에 의한 전달

-  배열은 일반 변수가 아닌 포인터에 의해 전달됨.
-  배열의 이름은 배열의 첫 번째 요소의 주소를 가리키는 포인터와 같음.
-  따라서 배열을 함수의 인자로 전달할 때는 배열의 주소를 전달하게 됨.

배열을 포인터로 전달하는 예제:

```
#include <stdio.h>

void func(int _pArr) {
for (int i = 0; i < 5; i++) {
printf("배열 요소: %d\n", _(pArr + i)); // 포인터로 배열 요소 출력
}
}

int main() {
int arr[] = {1, 2, 3, 4, 5};
func(arr); // 배열의 주소가 함수로 전달됨
return 0;
}
```

결과:

```
배열 요소: 1
배열 요소: 2
배열 요소: 3
배열 요소: 4
배열 요소: 5
```

-  함수 호출 시 배열의 이름 arr은 배열의 첫 번째 요소 주소를 가리키는 포인터로 전달됨.
-  함수 내부에서는 이 포인터를 통해 배열의 모든 요소에 접근할 수 있음.
  
<br>

## 3. 함수 호출 시 배열 전달의 메모리 구조

### 함수 호출 전:

    arr은 배열의 첫 번째 요소의 주소를 저장.
    각 배열 요소는 연속된 메모리 주소에 저장됨.

### 함수 호출 후:

    함수의 매개변수 pArr는 배열의 첫 번째 요소 주소를 전달받음.

    따라서, 함수 내부에서는 pArr을 통해 배열의 모든 요소에 접근 가능.
    
<br>

## 4. 정리

-  배열을 함수의 인자로 전달할 때 배열의 첫 번째 요소 주소가 전달됨.
-  따라서 포인터를 사용해 배열을 참조하게 되며, 함수 내부에서 배열의 요소 값을 변경하면 원본 배열에도 영향을 미침.
-  배열의 전달 방식과 메모리 구조를 이해하면, 효율적인 메모리 사용과 데이터 처리가 가능해짐.
