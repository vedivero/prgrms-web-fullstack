# 연산자

## 연산자 개요

-  연산자는 정적인 데이터들을 유기적으로 행동하게 하여 새로운 가치를 창출함.
-  예를 들어 학생들의 성적 데이터 자체로는 의미가 없으며, 총점 및 평균을 구하는 연산을 통해 데이터가 의미를 가짐.

## 연산자의 종류

-  산술 연산자: +, -, \*, /, % 등의 연산을 수행함.
-  대입 연산자: =, +=, -=, \*=, /=, %= 등을 사용해 값을 변수에 - 대입함.
-  부호 연산자: +, -로 양수나 음수를 표현함.
-  증감 연산자: ++, --를 통해 값을 1씩 증가 또는 감소시킴.
-  관계 연산자: ==, !=, <, >, <=, >= 등을 이용해 두 값의 관계를 비교함.
-  논리 연산자: &&, ||, !를 사용해 여러 조건을 결합하여 참(true)과 거짓(false)을 판단.
-  비트 연산자: &, |, ~, <<, >>를 사용해 비트 단위의 연산을 수행함.

## 논리 연산자

-  논리 연산자는 두 개의 조건식을 결합해 하나의 결과값을 만듦.
<br>
   1. ! (NOT 연산자)
   
   -  피연산자의 결과를 모두 반대로 만듦.
   -  피연산자가 true이면 false를 반환하고, false이면 true를 반환함.
      -  예: !a
<br>
   2. && (AND 연산자)
   
   -  모든 피연산자가 참일 때만 true를 반환함.
      -  예: a && b
<br>   
   3. || (OR 연산자)
   
   -  피연산자 중 하나라도 참이면 true를 반환함.
      -  예: a || b

<br><br>

# 함수

## 함수의 개념 및 동작 구조

-  함수형 기반 언어는 함수를 조합하여 프로그램을 구성함.
-  대부분의 프로그래밍 언어는 함수의 집합체로 이루어져 있음
-  각각의 함수가 유기적으로 연동하여 동작함.

## 함수의 동작 형태

-  C언어의 함수 동작:

   -  main 함수가 중심이 되어 함수1, 함수2, 함수3, 함수4와 같은 개별 함수들을 호출함.
   -  각 함수는 필요에 따라 데이터를 처리하거나 다른 함수와 상호작용함.

-  컴퓨터 내부 동작과 비교:

   -  CPU, 그래픽 카드, 메모리 카드, 사운드 카드 등이 메인 보드를 중심으로 유기적으로 동작함.
   -  각각의 구성 요소가 협력하여 시스템 전체가 정상적으로 작동함.

## 함수의 종류

1. 표준 함수:

   -  프로그래밍 언어에서 기본적으로 제공되는 함수를 의미함.
   -  라이브러리 형태로 제공되며 개발자가 편리하게 활용할 수 있음.

2. 사용자 정의 함수:

   -  사용자가 직접 필요에 맞게 함수를 설계하여 작성함.
   -  표준 함수만으로는 해결할 수 없는 특수한 작업을 수행할 때 사용됨.

## 함수의 기본 형태

-  예시: 더하기 함수 (Add)

   ```
   int Add(int a, int b) {
       return a + b;
   }
   ```

   -  자료형: int는 반환 값의 타입을 의미함.
   -  함수 이름: Add는 함수를 호출할 때 사용됨.
   -  인수 목록: (int a, int b)는 함수가 필요한 입력값을 의미함.
   -  함수 내용: a + b 연산을 수행하고 결과를 반환함.

## void 함수의 예시

void 타입 함수는 결과값을 반환하지 않음.

```
#include <stdio.h>

int Add(int i, int j);

void print_Start();
void print_Hap(int result);

void print_Start() {
    printf("======= Programming Start =======\n");
    printf("두 개의 정수를 입력하세요: ");
}

void print_Hap(int result) {
    printf("두 수의 합은 %d 입니다.\n", result);
    printf("======= Programming End =======\n");
}
```

-  print_Start(): 프로그램 시작 메시지와 사용자 입력 안내를 출력함.
-  print_Hap(int result): 계산 결과를 출력하고 프로그램 종료 메시지를 표시함.

-  Add(int i, int j): 두 정수의 합을 반환함.

# 변수의 범위

## 지역 변수와 전역 변수 개념 정리

1. 지역 변수

-  지역 변수는 특정 함수나 블록 내에서만 유효한 변수를 의미함.
-  같은 이름의 변수라도 서로 다른 함수에 선언되면 독립적으로 동작하며, 외부에서는 접근할 수 없음.

### 지역 변수의 특징:

-  함수가 호출될 때 스택 메모리에 생성되며, 함수가 종료되면 소멸됨.
   예시:

   ```
   void main(void) {
       int val = 0; // 지역 변수
       func1();
   }
   
   void func1() {
       int local = 10; // 지역 변수
   }
   ```

2. 전역 변수

-  전역 변수는 프로그램의 어디서나 접근 가능한 변수로, 함수 외부에 선언됨.
-  프로그램이 시작할 때 메모리에 할당되며 프로그램 종료 시 소멸됨.

### 전역 변수의 특징:

-  프로그램 내의 모든 함수가 전역 변수에 접근 가능함.

예시:

   ```
   int global; // 전역 변수
   
   void main(void) {
      global = 10;
      func1();
   }
   
   void func1() {
      global = 20;
   }
   ```

## 3. static 변수

-  static 변수는 선언된 함수 내에서만 유효하지만, 함수 호출이 끝나도 메모리에서 사라지지 않음.
-  프로그램 종료 시까지 값이 유지되며, 반복 호출 시에도 값이 초기화되지 않음.

static 변수 예시:

```
void func(void);

int main(void) {
    for (int i = 0; i < 5; i++) {
       func();
   }
   return 0;
}

void func(void) {
    static int value = 0; // static 변수
    value++;
    printf("%d\n", value);
}
```

```
실행 결과:
1
2
3
4
5
```

## 4. 메모리와 변수의 생명 주기

-  전역 변수: 프로그램 시작 시 생성되고, 프로그램이 종료될 때 소멸됨.
-  static 변수: 선언된 시점에서 생성되며 프로그램이 끝날 때까지 유지됨.
-  지역 변수: 함수 호출 시 생성되고, 함수가 종료되면 소멸됨.

# 배열

1. 배열 복사의 특징

   -  같은 타입끼리 복사가 가능함.
   -  배열은 배열끼리 복사할 수 있지만, 배열 전체를 직접 할당 연산자를 사용하여 복사할 수 없음.
   -  변수처럼 배열 전체를 복사하려고 하면 오류가 발생함.

   예시 코드 (오류 발생):

   ```
   int arr1[5] = {1, 2, 3, 4, 5};
   int arr2[5];
   arr2 = arr1; // 오류 발생
   ```

   ```
   에러 메시지: error C2106
   ```

   이유: 배열은 상수로 취급되기 때문에 단순 대입 연산자로 배열 전체를복사할 수 없음.

2. 배열 복사의 올바른 방법

   - 배열은 요소별로 복사해야 함.
   - 반복문을 사용하여 각 인덱스의 값을 순차적으로 복사할 수 있음.
   - 배열 복사 코드 예시:

   ```
   #include <stdio.h>

    int main() {
    int i;
    int arr1[5] = {1, 2, 3, 4, 5};
    int arr2[5];

        for (i = 0; i < 5; i++) {
            arr2[i] = arr1[i]; // 각 요소 복사
        }

        return 0;

    }
   ```

4. 배열 복사의 과정

   -  배열을 복사할 때, 각 요소를 인덱스별로 접근하여 복사함.
   -  예를 들어, arr1[0]의 값이 arr2[0]으로 복사되고, 같은 방식으로 모든 요소가 복사됨.

   배열 복사 흐름:

   ```
   arr1[0] → arr2[0]
   arr1[1] → arr2[1]
   arr1[2] → arr2[2]
   arr1[3] → arr2[3]
   arr1[4] → arr2[4]
   ```

<br><br>
