# 1. 요구사항 수집 및 분석

- 요구사항 수집
    - 시장 조사, 이해 관계자 인터뷰, 설문 조사, 문서 분석
- 요구사항 분류
    - 기능적 요구사항, 비기능적 요구사항
- 요구사항 분석
- 문서화
- 요구사항 검증 및 확인


# 2. 시스템 설계

## 1. 시스템 설계 종류

- 상위 설계
    - 시스템 아키텍처 설계
    - 모듈화
    - 데이터 설계
    - 인터페이스 설계
- 하위 설계
    - 데이터베이스 설계
    - 클래스 설계
    - 알고리즘 설계
    - 에러 처리 및 로깅 방식

## 2. 핵심 설계 원칙

- 모듈화(Modularity)
- 캡슐화(Encapsulation)
- 재사용성(Reusability)
- 확장성(Scalability)
- 응집도와 결합도(Cohesion and Coupling)
- 단순성(Simplicity)

## 3. 소프트웨어 아키텍처

- MVC (Model-View-Controller) 패턴
- 모놀리식(Monolithic) 아키텍처
- 마이크로서비스(Microservice) 아키텍처

## 4. 모놀리식 아키텍처

- 장점
    - 간단한 개발 및 배포
    - 손쉬운 디버깅
    - 용이한 테스트
- 단점
    - 개발 속도 저하
    - 배포의 어려움
    - 확장성 제한
    - 신뢰성 문제
    - 기술 채택의 장벽

## 5. 마이크로서비스 아키텍처

- 장점
    - 높은 안정성
    - 유연한 확장
    - 배포 용이성
    - 기술적 유연성
- 단점
    - 복잡성 증가
    - 네트워크 오버헤드
    - 디버깅 및 모니터링 어려움
    - 배포 복잡성


# 3. 테스트

## 1. 테스트 종류

- 단위 테스트 (Unit Test)
- 통합 테스트 (Integration Test)
- 시스템 테스트 (System Test)
- 인수 테스트 (Acceptance Test)
- 회귀 테스트 (Regression Test)
- 성능 테스트 (Performance Test)
- 보안 테스트 (Security Test)

## 2. 테스트 자동화

- 대표적인 프레임워크
    - JUnit
    - Selenium
    - Cypress
    - JMeter


# 4. 배포


## 1. 주요 활동

- 릴리스 준비
- 배포 계획 수립
- 배포 환경 구성
- 소프트웨어 배포
- 테스트 및 검증
- 문서화 및 교육
- 운영 및 모니터링

## 2. 웹애플리케이션 배포 방식

- 파일 복사
- 가상 서버 이미지 생성
- 컨테이너 이미지 생성

## 3. 배포 전략

- 롤링 업데이트 (Rolling Update)
    - 애플리케이션의 인스턴스를 하나씩 교체하여 배포.
    - 무중단 배포 가능, 그러나 롤백이 복잡.
- 블루-그린 배포 (Blue-Green Deployment)
    - 두 개의 환경(블루와 그린) 중 하나는 운영 중, 다른 하나는 업데이트 준비.
    - 빠른 롤백 가능하지만 인프라 비용이 증가.
- 카나리 배포 (Canary Deployment)
    - 소수 사용자에게 먼저 배포 후, 점진적으로 전체 배포.
    - 리스크가 낮고 안정적이나 트래픽 관리가 복잡.

## 4. 지속적 통합 (Continuous Integration)

- 소스코드 변경
- 코드 통합
- 자동화된 빌드
- 테스트 실행
- 결과 보고

## 5. 지속적 배포 (Continuous Deployment)

- CI를 통한 빌드 및 테스트
- 자동 배포
- 성능 및 안정성 모니터링
- 문제 발생 시 롤백
- 도구: Jenkins, Circle CI, Teamcity, Github Action

## 6. 모니터링 및 로깅

- 모니터링 도구: New Relic, Datadog, AWS Cloudwatch, Prometheus
- 에러 모니터링: Sentry, Rollbar
- 로깅 도구: AWS Cloudwatch Logs, Loki


# 5. 유지보수

- 버그 수정: 코드 내 오류 및 결함을 찾아 수정.
- 성능 최적화: 시스템 속도 및 자원 사용을 개선.
- 기능 개선 및 추가: 사용자 요구에 따라 새로운 기능 추가 및 기존 기능 강화.
- 기술 부채 관리: 누적된 기술적 부채를 해결해 시스템 유지 관리.
- 운영 환경 관리: 서버, 데이터베이스 등 시스템 운영 환경을 점검 및 관리.
- 보안 업데이트: 보안 취약점 수정 및 보안 패치 적용.

---

<br>
<br>
<br>
<br>


# 소프트웨어 개발 프로세스

## 1. 소프트웨어 개발 모델 종류
- 폭포수 모델
- 프로토타입 모델
- 나선형 모델
- 단계적 개발 모델
- 애자일 프로세스 모델

## 2. 각 모델의 설명 및 특징

### 1. 폭포수 모델 (Waterfall Model)
- 개념: 단계별로 순차적으로 진행하는 전통적인 소프트웨어 개발 모델.
- 단계: 요구사항 분석 → 설계 → 구현 → 테스트 → 배포 → 유지보수

- 특징:
    - 각 단계가 완료된 후 다음 단계로 진행됨.
    - 단계가 명확하게 구분되어 있음.
    - 이전 단계로 되돌아가기 어려움.
- 장점:
    - 프로젝트 관리가 용이하고 문서화가 잘됨.
    - 명확한 구조로 인해 초보자도 이해하기 쉬움.
- 단점:
    - 요구사항 변경에 대한 대응이 어렵고 유연성이 부족함.
    - 개발 기간이 길어질 수 있음.

### 2. 프로토타입 모델 (Prototyping Model)
- 개념: 초기 프로토타입을 빠르게 개발하고 고객 피드백을 받아 지속적으로 수정 및 개선하는 방식.
- 특징:
    - 초기 요구사항이 명확하지 않을 때 적합.
    - 고객과의 상호작용을 통해 제품 품질을 높임.
- 장점:
    - 고객의 요구사항을 반영하기 용이.
    - 사용자 요구를 직접적으로 반영하여 결과물이 만족스럽게 나옴.
- 단점:
    - 과도한 요구사항 변경으로 개발 기간이 길어질 수 있음.
    - 반복적인 수정으로 비용이 증가할 수 있음.

### 3. 나선형 모델 (Spiral Model)
- 개념: 나선을 그리며 개발을 반복하는 방식으로, 각 반복 주기마다 위험 분석과 평가가 포함됨.
- 특징:
    - 리스크 관리와 프로토타이핑을 동시에 진행.
    - 대규모 프로젝트에 적합.
    - 요구사항 분석과 설계를 반복하여 점진적으로 완성도를 높임.
- 장점:
    - 리스크를 조기에 식별하고 관리할 수 있음.
    - 반복 개발로 인해 점진적인 완성도 향상.
- 단점:
    - 복잡한 구조로 인해 소규모 프로젝트에는 적합하지 않음.
    - 비용과 시간이 많이 소요될 수 있음.

### 4. 단계적 개발 모델 (Iterative Model)
- 개념: 초기 시스템을 간단하게 구축하고, 반복적으로 기능을 추가하며 점진적으로 시스템을 완성하는 방식.
- 특징:
    - 부분적으로 동작하는 시스템을 빠르게 제공 가능.
    - 프로젝트 초기부터 운영 가능한 소프트웨어 제공.
- 장점:
    - 빠른 피드백을 통한 수정 및 개선 가능.
    - 사용자 요구사항 변경에 유연하게 대응 가능.
- 단점:
    - 초기 시스템이 불완전할 수 있음.
    - 전체적인 시스템 구조를 파악하기 어려울 수 있음.

### 5. 애자일 프로세스 모델 (Agile Process Model)
- 개념: 기능 단위로 개발을 진행하고, 고객과 지속적으로 상호작용하며 개발하는 방식.
- 특징:
    - 작은 단위의 스프린트(2~4주)를 반복.
    - 고객과의 긴밀한 협업을 통해 요구사항을 지속적으로 반영.
- 장점:
    - 변화하는 요구사항에 빠르게 대응 가능.
    - 개발 과정에서 고객의 만족도를 높일 수 있음.
- 단점:
    - 문서화가 부족할 수 있음.
    - 경험이 부족한 팀에서는 일정 관리가 어렵고 방향성을 잃을 수 있음.



---

<br>
<br>
<br>
<br>

# 소프트웨어 개발 방법론

## 0. 개요
![alt text](image.png)


## 1. 클라이언트-서버 모델

![alt text](image-1.png)
### 1. 작동 원리
- 클라이언트는 서버에 자원이나 서비스 요청을 보냄.
- 서버는 요청을 처리하고 결과를 클라이언트에게 반환.
- 프로토콜: 클라이언트와 서버 간 통신 규칙과 절차.
    - 예시: HTTP, SMTP, IMAP, FTP 등.

### 2. 클라이언트의 역할
- 서비스 요청
- 사용자 인터페이스(UI) 제공
- 입력 데이터 처리
- 서버로부터 응답 수신 및 처리

### 3. 서버의 역할
- 콘텐츠 제공
- 데이터 관리 및 저장
- 보안
- 동시 요청 처리
- 확장성 및 안정성 제공

### 4. 장단점
- 장점
    - 역할 분담: 클라이언트와 서버가 각자의 역할을 수행해 효율적임.
    - 중앙 집중화: 서버에서 모든 데이터와 자원을 관리하여 유지보수가 용이.
    - 확장성: 서버 용량 확장을 통해 시스템 확장이 가능.
    - 보안성: 서버에서 보안 정책을 통합적으로 관리 가능.
- 단점
    - 단일 장애점: 서버에 문제가 발생하면 전체 시스템이 작동하지 않음.
    - 서버 부하: 동시 접속자가 많아지면 서버에 과부하 발생.
    - 관리 복잡성: 서버의 유지보수와 보안 관리가 복잡할 수 있음.




## 2. 프론트 엔드

### 1. HTML Semantic Elements
- 정의: HTML에서 요소의 의미를 명확하게 나타내는 태그.
- 도입 이유:
    - 웹 접근성(Accessibility) 향상
    - SEO(검색 엔진 최적화) 개선
    - 유지 보수 및 코드 가독성 향상
- 예시:
    - header, footer, article, section, nav 등.

### 2. JavaScript의 역할
- 동적 콘텐츠 변경
- 사용자 이벤트 처리
- 애니메이션 및 효과
- 입력 데이터 검증
- AJAX를 이용한 비동기 통신

### 3. 프론트엔드 프레임워크
- Angular
    - Google에서 개발한 TypeScript 기반의 프레임워크. 컴포넌트 중심.
- React
    - Facebook이 개발한 JavaScript UI 라이브러리. 재사용 가능한 컴포넌트 기반.
- Vue.js
    - 직관적이고 유연한 반응형 UI 개발을 지원하는 프레임워크.
- Bootstrap
    - 반응형 그리드 시스템과 CSS 기반의 UI 컴포넌트를 제공하는 프레임워크.
- Tailwind CSS
    - 유틸리티 중심의 CSS 프레임워크로, 클래스 기반으로 빠르게 스타일링 가능.

### 4. 반응형 프로그래밍 패러다임 (Reactive Programming Paradigm)
- 개념: 데이터 스트림과 변경 사항 전파에 중점을 두는 선언적 프로그래밍 방식.
- 비교:
    - Imperative Programming: 명령어로 직접 상태 변경. (스위치를 직접 켜고 끔)
    - Reactive Programming: 데이터 흐름에 따라 자동으로 상태 변경. (스위치 상태에 따라 전등이 자동으로 반응)

## 3. 백 엔드

### 1. 주요 역할
- 데이터 처리 및 관리: 데이터베이스에서 데이터를 읽고 쓰는 작업 수행.
- 비즈니스 로직 구현: 애플리케이션의 핵심 기능 및 규칙을 서버에서 실행.
- API 제공: 클라이언트와 소통하는 인터페이스 개발.
- 서버 관리: 서버의 상태 모니터링 및 유지 보수.
- 보안: 사용자 인증 및 데이터 보호.

### 2. 프로그래밍 언어 및 프레임워크
- Java Spring MVC
- Python Django
- Node.js Express
- Ruby on Rails
- PHP Laravel

### 3. 서버 구성
- 웹 서버(Web Server): 클라이언트 요청을 받아 정적 콘텐츠(HTML, CSS, JS 등)를 제공.
- 애플리케이션 서버(Application Server): 동적 콘텐츠 및 비즈니스 로직을 처리.
- D- BMS(Database Management System): 데이터의 저장 및 관리.
- 구성 흐름:
- 클라이언트가 웹 서버에 요청.
- 웹 서버는 애플리케이션 서버에 요청을 전달.
- 애플리케이션 서버는 DBMS에서 데이터를 조회하고, 결과를 웹 서버에 반환.
- 웹 서버는 클라이언트에게 최종 결과를 반환.


## 4. 데이터베이스

### 1. 데이터베이스 개요
- 관계형 데이터베이스 (RDB, Relational Database)

    - 데이터를 테이블 형태로 저장하고 관리
    - SQL을 사용해 데이터를 질의 및 조작
    - 예시: MySQL, PostgreSQL, Oracle, SQL Server
    
- 비관계형 데이터베이스 (NoSQL Database)

    - 테이블 기반이 아닌 document, key-value, graph와 같은 다양한 데이터 저장 모델 사용
    - 유연한 스키마, 빠른 속도와 확장성 제공
    - 예시: MongoDB, Cassandra, Redis, DynamoDB

### 2. 관계형 데이터베이스 (RDB)
- 특징

    - 데이터는 **행(row)과 열(column)**로 구성된 테이블에 저장
    - 정규화를 통해 중복 데이터 최소화
    - 테이블 간 관계 설정 (Foreign Key)

- 장점

    - 데이터 무결성 보장
    - 복잡한 쿼리 및 트랜잭션 처리에 강함
    - 명확한 스키마 구조

- 단점

    - 스케일 아웃(Scale-out)이 어렵고, 주로 스케일 업(Scale-up)으로 확장
    - 복잡한 관계 설정으로 인해 초기 설계가 중요
- 활용 예시

    - 전자상거래, 금융 시스템, 기업 내 ERP

### 3. 비관계형 데이터베이스 (NoSQL)
- 특징

    - 비정형 및 반정형 데이터 저장 가능
    - 데이터 중복을 허용해 빠른 읽기/쓰기 성능
    - 유연한 스키마로 인해 데이터 모델 변경이 용이

- 유형

    - 키-값 저장소: Redis, DynamoDB
    - 도큐먼트 데이터베이스: MongoDB
    - 컬럼형 데이터베이스: Cassandra
    - 그래프 데이터베이스: Neo4j

- 장점

    - 수평 확장(Scale-out)에 유리
    - 대용량 데이터 처리 가능
    - 다양한 데이터 구조 지원

- 단점

    - 데이터 일관성 보장이 어려움 (Eventually Consistent)
    - 복잡한 쿼리 처리에 한계
- 활용 예시

    - 실시간 분석, 소셜 미디어, IoT, 게임 애플리케이션

### 4. 데이터베이스 선택 기준
- RDB 선택 기준

    - 데이터의 무결성과 복잡한 트랜잭션이 필요한 경우
    - 예: 금융, ERP 시스템
- NoSQL 선택 기준

    - 빠른 처리 속도와 수평 확장이 필요한 경우
    - 예: SNS, 실시간 데이터 분석, 로그 수집

### 5. 예시 데이터
- RDB 예시 (users table)

    | id | name  | email              | password  |
    |----|-------|--------------------|-----------|
    | 1  | 홍길동 | gildong@gmail.com  | 12345678  |
    | 2  | 이순신 | soonshin@gmail.com | 11111111  |
    | 3  | 유관순 | youks@gmail.com    | idontknow |



```json
{
  "_id": "12345",
  "name": "John Doe",
  "email": "john.doe@example.com",
  "address": {
    "street": "123 Elm Street",
    "city": "Springfield",
    "zip": "12345"
  },
  "orders": [
    {"order_id": "5001", "amount": 150},
    {"order_id": "5002", "amount": 200}
  ]
}
```

## 5. 캐싱

### 1. 캐싱 개념
- 자주 사용되는 데이터나 계산 결과를 미리 저장해 두고, 동일한 요청이 왔을 때 빠르게 응답하도록 해주는 기술
- 주요 기술: Redis, Memcached (메모리 기반 key-value 저장소)

### 2. 캐싱 종류
- 객체 캐싱
    - 사용자 세션
    - 뉴스 기사
    - 장바구니
- 페이지 캐싱
    - 뉴스 메인 페이지
    - 게시글 페이지
- 브라우저 캐싱
    - 관련 헤더: ETag, Last-Modified

### 3. 캐싱의 장단점
- 장점

    - 응답 시간 단축
    - 서버 부하 감소
    - 네트워크 부하 감소
- 단점

    - 만료된 데이터(stale data) 사용 가능성
    - 복잡성 증가

### 4. 캐시 무효화 전략
- 명시적 무효화
    - 데이터베이스 등의 원본 데이터가 변경되었을 때 캐시 데이터를 업데이트하거나 제거
- 만료시간(TTL) 기반 무효화
    - 캐시된 객체에 TTL을 설정하여 일정 시간이 지나면 해당 객체를 무효화
- 버전 기반 무효화
    - 캐시 데이터에 버전 번호를 할당하여 무효화를 관리


## 6. 로깅 (Logging)

- 목적

    - 시스템이나 애플리케이션에서 발생하는 이벤트를 저장 및 관리
    - 디버깅(Debugging), 성능 모니터링, 보안, 감사(Audit)

- 고려사항

    - 로그 레벨: DEBUG, INFO, WARN, ERROR, FATAL
    - 로그 포맷
    - 로그 로테이션
    - 로그 보안
    - 로그 관리 도구: ELK 스택, CloudWatch Logs


## 7. Job Server

### 1. Job Server란?
- Job Server는 큐에 추가된 작업을 가져와 Worker에게 전달하고, 결과를 관리하는 서버
- 역할
    - 큐에서 Job을 Polling(주기적 확인)하여 가져옴
    - Worker에게 Job을 할당하고, 처리 완료 후 상태를 확인
    - 실패한 Job은 다시 큐에 추가하거나 실패 처리 로직을 수행
    - 백그라운드 작업을 처리하며 시스템의 부하를 줄이고 효율적인 분산 처리가 가능
### 2. Job Server 사용 예시
- 이메일 대량 발송
- 영상 인코딩
- PDF 생성 작업
- 데이터 집계 및 분석
- 예시 (Laravel Queue 시스템)
- Laravel 프레임워크에서는 Job Server와 Worker, Queue가 상호작용하여 대규모 작업을 분산 처리할 수 있도록 지원합니다.
- 이를 통해 클라이언트 요청에 빠르게 응답
- 시간이 오래 걸리는 작업은 별도로 처리

### 3. 작업 큐(Job Queue) 동작 방식
- Job 생성
    - 사용자가 특정 요청을 하면 Job이 생성됨
- Job Queue에 작업 추가
    - 생성된 Job은 큐에 추가되어 순차적으로 처리됨
- Job Server에서 작업 가져오기
    - Job Server는 큐에서 작업을 Polling 방식으로 가져와 처리
- Worker에서 작업 처리
    - Job Server에 의해 할당된 작업을 Worker가 수행
- 작업 완료 및 결과 처리
    - 작업이 완료되면 결과가 저장되고 클라이언트에 반환됨
- 작업 실패 처리
    - 실패한 작업은 다시 큐에 넣거나 별도의 실패 처리 로직을 수행

### 4. 작업 종류
- 이메일 발송
- 데이터 처리 및 분석 작업
- 파일 변환
- 외부 API 호출
- 주기적인 작업 (cron job)

### 5. 장점
- 응답 속도 향상
    - 클라이언트는 작업 요청 후 즉시 응답을 받고, 실제 작업은 백그라운드에서 수행됨
- 확장성
    - 여러 Worker를 통해 대량의 작업을 병렬로 처리 가능
- 작업 실패 처리 및 재시도
    - 실패한 작업은 재시도 로직을 통해 안정적으로 처리됨